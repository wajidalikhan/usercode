This directory contains all of the necessary code and files for running the Bayesian limits for the displaced
lepton analysis. It also includes code for the background estimation (see further down for documentation on that).

Here's a quick overview of how to use the contents.

==== Table of Contents ====
** Running the limit calculation
** Data files
** Background estimation
** Updating efficiencies
** Updating resolutions
** Miscellaneous (and outdated) scripts

==== Running the limit calculation ====

0) Getting set up -- to set up your environment, use either setup.csh or setup.sh as appropriate. For
some reason, setup.csh doesn't work properly if sourced; just cat it and paste the commands directly into
your terminal window.

1) Input data -- most of the scripts rely on the files in WinterSelection/ for the input data. These
files are generated from the WinterFigs/selection directory in the svn repository for the note. Contained
within WinterSelection/ is a simple Perl script, regenerate_selection_files.pl, which will copy all of
the files from the repository directory. Just change the repository location at the top of
regenerate_selection_files.pl and run it to repopulate WinterSelection/ whenever necessary.

2) Making the limits -- there are two parallel paths one can use to run the limits:

- To run the limits on the number of events as a function of mass, use mainMass.py. The syntax is simply
  python mainMass.py Mass LeptonType
where LeptonType should be either "Electron41" or "Muon33" (other pt cuts are in principle supported but
the support may not be complete in places) and Mass is simply the X boson mass.

The resulting output file will simply be named MASS.txt; you should move it into some final directory
when it's done. This is a very fast process, usually taking only a few seconds to run, but of course for
a lot of masses this time can add up, so there's also a simple script submitMass.py, which you can run
with
  python submitMass.py LeptonType
which will submit jobs for masses from 15 to 500 at 1 GeV/c^2 intervals.

- To run the limits on the cross-section times branching ratio as a function of lifetime, use
mainSigmaBayesian.py. The syntax is a little more complex:
  python mainSigmaBayesian.py Mass LeptonType Eff EffErr [FileName]

Mass and LeptonType are as before. Eff is the total efficiency, which normally is given by
2*e1*br*(1-br) + 2*e2*br^2, and EffErr should be the error on the above. If FileName is blank, then the
output file will just be MASS.txt as before; if specified, the resulting file will be placed in
LeptonTypeBayesianWinterFreeze/FileName.txt (this can be changed in mainSigmaBayesian.py).

Again, there exists a helper script to run all of the jobs. This is currently submitLifetimeJobs_41_33.pl. This
script has all of the efficiencies and their errors stored within (for details on how to update these numbers, see
below), so just run ./submitLifetimeJobs_41_33.pl and it will run everything. (This does not include the mH=125
points, but ./submitLifetimeJobs_41_33_125.pl exists for the mH=125 points.)

These scripts use GetWorkspaceMass.py and GetWorkspaceSigma.py to set up the RooFit workspace, and
GetLimitBayesian.py to get the final Bayesian limit. roostats_cl95.C is the standard roostats_cl95 script
with an additional hack to support 3-sigma limits as well to compute the expected limits.

3) Plotting the limits

PlotLimitsMass.py will plot the limits on the number of events as a function of mass. You can run it
simply with python PlotLimitsMass.py LeptonType. The input directory is specified inside the file at the
top.

Similarly, PlotLimitsLifetimeExpected.py will plot the limits on the cross-section as a function of
lifetime. This takes two arguments: python PlotLimitsLifetimeExpected.py LeptonType HiggsMass. Again, you
can change the input directory in the file.

These scripts also use tdrstyle.C to set up the TDR style as appropriate for the plots.

==== Data files ===

The various parameters used in the fits are, unfortunately, scattered in several different places (some effort to
consolidate everything is planned, but has not yet been carried out). Specifically:

* The "data files" (dataFileElectron41 and dataFileMuon33) contain the background estimate and the uncertainty on
  that estimate, the luminosity and its uncertainty, and the signal resolution and its uncertainty, expressed as a
  series of polynomial coefficients -- that is, SigWidth a b c means that the signal resolution is a + b*mx +
  c*mx^2. Note that the "SigEff" and "SigEffE" (signal efficiency) defined in this file is not actually used -- in
  the case of the limits on number of events, it is of course not relevant, and for the limits on the
  cross-section, it is overridden by the values passed on the command line to mainSigmaBayesian.py, as described
  above.
* The background shape function and the parameters of the fit are defined directly in GetWorkspaceSigma.py and
  GetWorkspaceMass.py (unfortunately the code is duplicated in the two files) -- look for the definition of
  bkgPdf.
* The signal efficiencies for the different mH/mX/ctau samples are stored in the submission script
  submitLifetimeJobs_41_33.pl as described above. For information on how to update these, see below.

==== Background estimation ====

* makeBackgroundFits.C is a script for performing the fits for the background normalization. It is designed to run
over a variety of different scenarios:
 - first, a variety of selection requirements (e/mu and the pt cut used). Although it was originally designed for
using many different pt cuts, in practice it has only been used for the "default" cases (for 2011, electron_pt41
and muon_pt33), so much of the other data has not been kept up to date.
 - second, three different fitting scenarios: either a fit to MC simulation using only the background region
(extrapolating into the signal region), a fit to MC simulation using the full region (this is the method used for
the 2011 background normalization), or a fit to data using only the background region.

Note for that the muon channel, the second exponential is fixed (see l. 58), so be aware of this -- you might want
to change it depending on your configuration.

In order to run,
 - adjust the lumi for each pt scenario of interest in lumi[]
 - set the starting fit parameters appropriately in startingFitParameters[]. Because the fits are based on so few
events, the fits are often very finicky, so you'll have to set reasonable starting parameters in order to get good
values. This is a 3-D array: the first is the sample, the second is the fit configuration: 0=MC background only,
1=MC full range (the final fit), and 2=data background only, and the third is the four fit parameters (normalization and
multiplicative factor for the 1st exponential, then normalization and multiplicative factor for the 2nd exponential).
 - specify which plots you're actually interested in making (the nplots and whichplots[] variables below)

Then run. Plots will be produced for each of the three fitting scenarios (in the order MC background, MC full, data
background), and the integral for each (the actual background estimation) will be displayed. The MCAll plots will
also be saved in both png and pdf format (you can also uncomment the option to print the MCBkg or DataBkg plots as
well).

* fitBackgroundPDFBW.C is a script for performing the fit to the background shape. To use it, make sure the files
in WinterSelection/ are up to date, set the lumis at the top of the file appropriately, and then:
 - select the desired channel by setting isMu to true or false
 - set data/MC by setting isData to true or false
 - set isPrompt to true to use the "prompt" (no lifetime cuts) sample, or false to use the "loose cuts" sample
 - if isPrompt is false, set isLoose1 to true to use the "loose_1" cuts, or false to use the "loose_2" cuts

Then run. Note that this will be quite quick for the non-prompt sample, but will take several minutes (longer for
the muon) for the prompt sample due to the very large numbers of events. Two versions of the output plot will be
produced: one suitable for a note including the box with the fit parameters, and one suitable for a paper/PAS
without the box. Note that you may have to change from "CMS" to "CMS Preliminary" depending on use.

To change how the fit works:
 - You can change the fit range using the lowBound/highBound parameters.
 - By default, the fit is performed unbinned. You can also perform the fit binned by using data_binned in the
signalPdf.fitTo() call. In this case you may also want to adjust rebinFactor to adjust the binning of the fit.
 - To change the fit function, there are a very large number of building blocks in the middle of the code commented
out. You can change the base function, add convolution, and change the function added to it by uncommenting various
blocks of code. Hopefully it is relatively self-explanatory.

==== Updating efficiencies ====

parseEfficiencyFiles.pl is a rather complex Perl script to take the efficiency files prepared by the selection code
and transform them into formats more suitable for the rest of the analysis. Specifically, it will take files of the
form efficiencies_di{electron,muon}{1,2}[_ctaufact_CTAUFACTOR][_{pileup,statistical}_uncertainty.txt] and output
the efficiencies.

Things to know about parseEfficiencyFiles.pl:
 * The input files will be read from the WinterSelection directory, so make sure those are up-to-date before
running.
 * The pileup uncertainty is treated specially, since currently the script only calculates the pileup uncertainty
for the nominal lifetime. The default is to use this as a relative uncertainty when applying it to other lifetimes
($useRelativePileupUncertainty == 1); if zero, then this will be treated as an absolute uncertainty instead. You
can also disable to the pileup uncertainty entirely by setting $usePileupUncertainty = 0.
 * The tracking systematic (as a relative uncertainty) is specified by $trackingsys_rel.
 * The ctau factors present in the file are specified in the ctaufactsIn array, while the ctau factors to generate
the final efficiency numbers are specified in the ctaufactsOut array (as these two may not be the same).
 * Similarly, the %masses hash stores the various H and X masses present in the input files, while %used_masses
stores the H and X masses for which we are interested in generating output.
 * %nominal_lifetimes stores the nominal ctau values (in cm) for the different samples.
 * %nlo_systematic is an additional systematic for the NLO uncertainty for the mH=125 samples; it is also expressed
in relative terms.
 * $br is the nominal "small" branching ratio (set to 0.01) for computing the total efficiency given the e1 and e2
factors.

Once everything is set up properly, simply run. The program produces a rather large amount of output in a truly
impressive variety of languages, each destined for a different source. In each case, the output is designed to
simply be copied and pasted into the appropriate script:

The first set (the C code beginning with "Results by lifetime") is designed for making fits in ROOT using, for
instance, makeEfficiencyFitsLifetime.C. The second set of numbers (the Perl code beginning with "Effective
efficiency values") is designed to be used in the submission scripts such as submitLifetimeJobs_41_33.pl; merely
cut and paste the appropriate values into the script. The third set of numbers (the Python code beginning with
"Results by lifetime for Ian") is designed to go into Ian's CLs limit scripts. Finally, the last chunk of output
(beginning with "Latex table of efficiencies") is a LaTeX section designed to be put into the note with the final
efficiency values.

==== Updating resolutions ====

makeWidthFitsResolution.C is a simple script to fit the mass resolutions and errors as a function of mass. It takes
massResolutions, the text file prepared by Andrzej, and fits curves to the resulting data. It can be run in two
modes: in the default (useAllResolutions == false), only the resolution at the nominal lifetime (ctaufact == 1)
will be used for the fits. If useAllResolutions == true, then the resolution is determined by the mean of all
values and the error by the spread of those values.

You can see the expected format of the massResolutions file in the version currently in svn. Note that if the
number of masses or lifetimes present in this file change,s you will need to change nmass or nlife respectively.

Once the new fits have been performed, enter them into the appropriate data files (e.g. dataFileElectron41).

==== Miscellaneous (and outdated) scripts ====

tdrstyle.C is a copy of the official TDR style script for ROOT.

roostats_cl95.C is a copy of the RooStats_cl95 script for computing limits. For more documentation, see
https://twiki.cern.ch/twiki/bin/viewauth/CMS/RooStatsCl95
The version here has been hacked slightly to return +/-3 sigma limits in addition to the default (which is only
+/-1 and +/-2 sigma).

getEventTotals.pl is a simple utility script for computing the total number of events with their uncertainty in a
text file. Just provide the name of the file on the command line. This simple method has been largely superseded by
Ian's more sophisticated way of handling the uncertainty on the background estimation (see Appendix D of AN-11-486
for further information).

makeBackgroundFitsLoose.C is a variant of makeBackgroundFits.C using the loose samples, for various crosschecks
requested during the review process. It is run the same way.

makeBackgroundCDF.C is a simple script to make the background cumulative distribution function (CDF), which was
requested in one of the rounds of comments on the paper. It works quite similarly to (and is derived from)
fitBackgroundPDFBW.C, so just adjust the input as desired and run.

makeLouvainPlot.C produces a plot requested by Louvain of the background mass distribution divided into bins of
varying Lxy/sigma. It is also based on fitBackgroundPDFBW.C, so can be used quite similarly.

fitBackgroundPDFBWBare.C is an old version of fitBackgroundPDF.C which performs the fit using straight ROOT (no
RooFit). It is no longer kept up to date.

makeEfficiencyFitsLifetime.C is an old experimental script to fit the efficiencies as a function of lifetime. If
you'd like to use it, change the numbers as appropriate, paste in the new efficiencies as produced by
parseEfficiencyFiles.pl, and proceed.

makeEfficiencyFitsLifetime2D.C is similar, but attempts to do a 2D fit vs. mass and lifetime.

makeWidthFits.C is an old, simple script to fit the mass resolution and error as a function of mX (these use the
four samples for mH=1000). It has been superseded by makeWidthFitsResolution.C.