#include <TFile.h>
#include <TString.h>
#include <iostream>
#include <fstream>
#include <string>
#include <TH1F.h>
#include <TFile.h>
#include <TH1.h>
#include <TKey.h>
#include <TROOT.h>
#include <THStack.h>
#include <TLegend.h>
#include <TCanvas.h>
#include <TLatex.h>

#include "analysisType.C"

TString getTypeName(analysisType ana)
{
  TString type("");

  if ( ana==_2eTrack) type = "2eTrack";
  else if ( ana==_2muTrack ) type = "2muTrack";
  else if ( ana==_2globalMu ) type = "2globalMu";
  else if ( ana==_2trackerMu ) type = "2trackerMu";
  else if ( ana==_2saMu ) type = "2saMu";

  return type;
}

float getLumi(const bool electrons)
{
  TString lumiFile = "";
  if( electrons ) lumiFile = "LumiFiles/lumi_electron.txt";
  else lumiFile = "LumiFiles/lumi_muon.txt";

  // Read file to get lumi (in /pb)
  ifstream openFile;
  openFile.open(lumiFile.Data());
  // Only one line in file...
  string lumiString = "0";
  if (openFile.is_open()) {
    getline(openFile, lumiString);
    openFile.close();
  }
  return ::atof(lumiString.c_str());
}

//TLegend *legend= new TLegend(0.7,0.6,0.9,0.85);
void addHistogram(const TString & fileName, const TString & histoName, const int color, THStack & hs, const TString & leg, TLegend *legend, const float lumi, double & integral, double & integralError2 )
{
  TFile * inputFile= new TFile (fileName, "READ");
  TH1F * histo = (TH1F*)inputFile->Get(histoName);
  TH1::SetDefaultSumw2();
  histo->Scale(lumi);

  // Sum total integral of background MC
  double integralError=0;
  integral += histo->IntegralAndError(1,histo->GetNbinsX(),integralError);
  integralError2 += integralError * integralError;

  histo->SetFillColor(color);
  //  histo->Rebin(5);
  hs.Add(histo);

  legend->AddEntry(histo, leg, "f");
}

void makePlot(const TString & histoName, TFile * outputFile, TString type, const TString & xTitle,  const double & yMin = 0., const double & yMax = 0., const bool electrons = false, const float lumi = 0, const bool plotData=false )
{
  std::cout << "----> Making plots for : " << histoName.Data() << std::endl;
  TH1::SetDefaultSumw2();

  // Make title for stacks
  TString stackTitle = "CMS #sqrt{s} = 8 TeV, L = ";
  char s[32];
  sprintf(s, "%.1f",lumi/1000);
  stackTitle += s;
  stackTitle +="fb^{-1}";

  THStack hs("hs",stackTitle);
  TString latexText = "#mu^{+}#mu^{-}";
  if (electrons) {
    hs.SetTitle(stackTitle);
    // hs = THStack("hs",);
    latexText = "e^{+}e^{-}";
  }


  TH1F * histoData=0;
  if (plotData) {
    //
    // DATA
    //

    std::cout << "Getting data file" << std::endl;
    TFile * inputFile= new TFile ("CombinedFiles/Data_combined"+type+".root", "READ");
    std::cout << "Getting data histogram" << std::endl;
    histoData = (TH1F*)inputFile->Get(histoName);

    std::cout << "Calculating integral of data histo" << std::endl;
    double dataIntegralError = 0;
    double dataIntegral = histoData->IntegralAndError( 1, histoData->GetNbinsX(), dataIntegralError );
    std::cout << "Integral of Data : " << dataIntegral << " +/- " << dataIntegralError << endl;
  }

  //
  // BACKGROUND MC
  //

  double mcIntegral = 0;
  double mcIntegralError2 = 0;
  std::cout << "Doing MC" << std::endl;
  TLegend *legend= new TLegend(0.65,0.6,0.85,0.85);
    addHistogram("CombinedFiles/ZZ_combined"+type+".root", histoName, 8, hs,"ZZ", legend, lumi, mcIntegral, mcIntegralError2);
    addHistogram("CombinedFiles/WZ_combined"+type+".root", histoName, 7, hs,"WZ", legend, lumi, mcIntegral, mcIntegralError2);
    addHistogram("CombinedFiles/WW_combined"+type+".root", histoName, 6, hs,"WW", legend, lumi, mcIntegral, mcIntegralError2);
    addHistogram("CombinedFiles/WJets_combined"+type+".root", histoName, 5, hs,"WJets", legend, lumi, mcIntegral, mcIntegralError2);
   addHistogram("Ztautau_combined"+type+".root", histoName, 97, hs,"Z/#gamma*->#tau#tau",legend, , lumi);
  addHistogram("CombinedFiles/DYJets_combined_"+type+".root", histoName, kRed, hs,"DYJets", legend, lumi, mcIntegral, mcIntegralError2);
   addHistogram("TTbar_combined"+type+".root", histoName, 3, hs,"tt", legend, lumi);
    addHistogram("CombinedFiles/TTJets_combined"+type+".root", histoName, 3, hs,"tt+jets", legend, lumi, mcIntegral, mcIntegralError2);
    addHistogram("CombinedFiles/QCD_combined"+type+".root", histoName, kBlue, hs,"QCD", legend, lumi, mcIntegral, mcIntegralError2);

  std::cout << "Integral of MC : " << mcIntegral << " +/- " << sqrt(mcIntegralError2) << endl;

  //
  // SIGNAL MC
  //

  std::cout << "Getting signal histograms" << std::endl;
  TFile * signalInputFile1= new TFile ("WeightedFiles/HTo2LongLivedTo4F_MH200_MFF50_CTau20To2000_analysis_20120911_weighted_"+type+".root", "READ");
  TH1F * histoSignal1 = (TH1F*)signalInputFile1->Get(histoName);
  histoSignal1->Scale(lumi);

  TFile * signalInputFile2= new TFile ("WeightedFiles/HTo2LongLivedTo4F_MH1000_MFF350_CTau35To3500_analysis_20120911_weighted_"+type+".root", "READ");
  TH1F * histoSignal2 = (TH1F*)signalInputFile2->Get(histoName);
  histoSignal2->Scale(lumi);


  // Output histograms to file
  outputFile->cd();
  TCanvas canvas(histoName);
  canvas.cd();
  gPad->SetLogy();
  canvas.Draw();
  canvas.SetFillColor(kWhite);
  canvas.SetBorderMode(0);
  hs.Draw("HISTE");
  hs.GetXaxis()->SetLimits(0, 500);
  double xlatex = 20;
  if(xTitle=="mass[Gev/c^{2}]") {
    hs.GetXaxis()->SetLimits(0, 500);
    xlatex = 20;
  }
  else if (xTitle=="Sum pt, low pt lepton" || xTitle=="Sum pt, high pt lepton") {
    hs.GetXaxis()->SetLimits(0, 25);
    xlatex = 20;
  }
  else if (xTitle=="N reco PV" || xTitle=="N vtx true") {
    gPad->SetLogy(0);
    hs.GetXaxis()->SetLimits(0, 60);
    xlatex = 20;
  }
  else if (xTitle=="cos{#alpha}") {
    gPad->SetLogy(1);
    hs.GetXaxis()->SetLimits(-1.1, 1.1);
    xlatex = 20;
  }
  else if (xTitle=="Vertex #chi^{2}") {
    hs.GetXaxis()->SetLimits(0, 20);
    xlatex = 20;
  }
  else if (xTitle=="L_{xy}") {
    hs.GetXaxis()->SetLimits(0, 25);
    xlatex = 20;
    legend->SetX1(0.2);
    legend->SetX2(0.35);
  }
  else if (xTitle=="lepton L p_{t} [GeV/c]" || xTitle=="lepton H p_{t} [GeV/c]") {
    hs.GetXaxis()->SetLimits(0, 500);
    xlatex = 20;
  }
  else if (xTitle=="d0 H" ||xTitle=="d0 L" ) {
    hs.GetXaxis()->SetLimits(0, 0.5);
    xlatex = 20;
  }
  else {
    hs.GetXaxis()->SetLimits(0, 20);
    xlatex = 1;
    legend->SetX1(0.2);
    legend->SetX2(0.35);
  }
  if( yMin != 0. && yMax != 0. ) {
    hs.SetMinimum(yMin);
    hs.SetMaximum(yMax);
  }
  hs.GetXaxis()->SetTitle(xTitle);
  hs.GetYaxis()->SetTitle("Entries");

  if ( plotData ) {
    histoData->SetMarkerStyle(20);
    histoData->SetMarkerSize(1);
    histoData->Draw("same,P,E,X0");
  }

  histoSignal1->SetLineStyle(2);
  histoSignal1->SetLineColor(4);
  histoSignal1->Draw("same,HIST");

  histoSignal2->SetLineStyle(2);
  histoSignal2->SetLineColor(8);
  histoSignal2->Draw("same,HIST");

  legend->SetBorderSize(0);
  legend->SetFillStyle(0);
  legend->AddEntry(histoData,"data","p");
  legend->AddEntry(histoSignal1,"signal1","l");
  legend->AddEntry(histoSignal2,"signal2","l");

  legend->Draw();

  TLatex *l1 = new TLatex(xlatex, yMax*7/10, latexText);
  l1->Draw();

  canvas.Write();

  outputFile->Write();
  //  outputFile->Close();
}

void makeAllPlots( analysisType ana, bool plotData )
{

  bool electrons=false;
  if (ana==_2eTrack) electrons=true;

  TString type(getTypeName(ana));

  // Get lumi
  float lumi = 5000;
  if ( plotData ) {
    lumi = getLumi(electrons);
    std::cout << "Total lumi in data : " << lumi << " /fb" << std::endl;
  }
  else std::cout << "Not plotting data, will normalise to lumi of " << lumi/1000 << " /fb" << std::endl;

  TFile * outputFile = new TFile("output_"+type+".root", "RECREATE");

  makePlot("Mass_veryLooseCuts", outputFile, type, "mass[Gev/c^{2}]", 0.07, 10000000, electrons, lumi, plotData);
  makePlot("leptonPtL_veryLooseCuts", outputFile, type, "lepton L p_{t} [GeV/c]", 0.07, 10000000, electrons, lumi, plotData);
  makePlot("LxySig_veryLooseCuts", outputFile, type, "Candidate L_{xy}/#sigma_{xy}", 0.07, 10000000, electrons, lumi, plotData);

  makePlot("Mass_finalCuts", outputFile, type, "mass[Gev/c^{2}]", 0.07, 10000000, electrons, lumi, plotData);
  makePlot("Mass_invertedLifetimeCuts", outputFile, type, "mass[Gev/c^{2}]", 0.07, 10000000, electrons, lumi, plotData);

  outputFile->Close();
}

